https://segmentfault.com/a/1190000016566788


一、数据库的事物的基本特性
事物是区分文件存储系统与Nosql数据库重要特性之一，其存在的意义是为了保证即使在并发情况下也能正确的执行crud操作。怎样才算是正确的呢？这时提出了事物需要保证的四个特性即ACID：
* A: 原子性(atomicity)
>事物中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事物的失败；
* C: 一致性(consistency)
>事物结束后系统状态是一致的；
* I:  隔离性(isolation)
>并发执行的事物彼此无法看到对方的中间状态；
* D: 持久性(durability)
>事物完成后所做的改动都会被持久化，即使发生灾难性的失败。

* 在高并发的情况下，要完全保证其ACID特性是非常困难的，除非把所有的事物串行化执行，但带来的负面的影响将是性能大打折扣。很多时候我们有些业务对事物的要求是不一样的，所以数据库中设计了四种隔离级别，供用户基于业务进行选择。

|隔离级别|	脏读（Dirty Read）	|不可重复读（NonRepeatable Read）|	幻读（Phantom Read）|
|:-----|:-----|-----:|-----:|
|未提交读（Read uncommitted）	|可能	|可能|	可能|
|已提交读（Read committed）	|不可能	|可能|	可能|
|可重复读（Repeatable read）|	不可能	|不可能|	可能|
|可串行化（SERIALIZABLE）	|不可能	|不可能	|不可能|

* **脏读**
   * 一个事物读取到另一事物未提交的更新数据    
  > t2写 t1读  t2回滚 ，  t1 还是能读取到数据的结果
* **不可重复读**
  * 在同一事物中,多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事物已提交的更新数据. 相反, “可重复读”在同一事物中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事物已提交的更新数据。
  >  t1读 t2写 t1读 显示结果不一样
* **幻读**:
  * 查询表中一条数据如果不存在就插入一条，并发的时候却发现，里面居然有两条相同的数据。这就幻读的问题。 
  > t1 读 t2 写   t1 写     t1写不进去
  
  ```
  > 幻读解决方法 t1 读手动加   X 锁（写锁）
  > X 锁 也称为写锁 事物T对数据 加 X锁 , 则事物T可以对数据读取和修改， 但其他事物不可以对数据加S/X锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。
  > S 锁 也称为读说，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改
  ```
数据库默认隔离级别：
Oracle中默认级别是 Read committed
mysql 中默认级别 Repeatable read。另外要注意的是mysql 执行一条查询语句默认是一个独立的事物，所以看上去效果跟Read committed一样。
# 查看mysql 的默认隔离级别
SELECT @@tx_isolation
